sync primitive:
	spinlock
	
system:
	task based environment
	
	
DESIGN:

task based environment:


USER INTERACTIONS:

User Job:
	function to execute, associared data
	
Job usage
	allocates on the stack
	setup them
	queue them
	wait for a group of job to end their execution
	
Scheduling:
	The user doesn't know how the scheduling is performed

Environment initialization:
	the user can choose how many threads will be used
	the user can choose th amount of allocated User Job handler (discussed in the next section)

	
Error handling:
	exception ?
	assert ?
	error code ?
	nothing ?
	
	
INTERNAL DESIGN:

fundamuntal principles:
	- easy to use and read
	- self balanced system
	- can allocate jobs on stack (no handles to hold jobs)
	- can use sync primitive, and associate with a set of jobs
		- you decide when to allocate/free the job sync primitive
		- you are responsible to use it properly


Execution Core:
	agent which is holding a job (th function and its data)
	may contains an associated object to use once it is finished (counter or anything else)
	
How EC are stored ?
-fixed amount ?
- dynamic amount ?

Where EC are stored ?
- global container ? => locked access on allocation
	- if EC are in fixed amount, easy to decide a sufficient amount of job for your applucation
	- if EC are in dynamic amount, no problem (but could have consequences durng job allocation)
	
- per thread container ?
	- if EC are in fixed amount, you don't know which thread will be more used to queue jobs, you could quickly ran out of jobs, or have lots of unused jobs in other threads
	- if EC are in dynamic amount, no problem (but could have consequences durng job allocation)
	
	
JOB Queue operation:
	- query EC
	- setup EC
	- move EC from available to usable EC
	
Wait operation:
	- try to execute another EC
		- if using fibers, you have to queue the current fiber to a dedicated container
		
		
EC queue retrieval:
by bunchs
could use a pool to begin


EC execution retrieval:	
one by one
FIFO pattern

EC execution policy:
check if there is any wainting job now ready to be finished, it so then execute it
otherwise execute a new job
	-could try to execute one of its jobs
	- if there is no jobs to execute, try to steal one from another pool
		- how to know which pool to choose ?
			- random ?
			- keep a list of busy pools ?